<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tip on {Pervasion} numérique</title>
    <link>https://infores-sn.github.io/tags/tip/index.xml</link>
    <description>Recent content in Tip on {Pervasion} numérique</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <copyright>&amp;copy; 2016 Claude Defrance</copyright>
    <atom:link href="/tags/tip/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Astuce binaire : extraire la valeur d&#39;un bit en C</title>
      <link>https://infores-sn.github.io/post/bitwise-hack/</link>
      <pubDate>Fri, 06 Jan 2017 17:13:37 +0000</pubDate>
      
      <guid>https://infores-sn.github.io/post/bitwise-hack/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Voici une astuce découverte par hasard dans un fichier source de la librairie standard d&amp;#8217;Arduino.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;À l&amp;#8217;occasion de la préparation d&amp;#8217;un cours d&amp;#8217;initiation à l&amp;#8217;électronique traitant des registres à décalage, je suis tombé sur une astuce de manipulation de bits que je n&amp;#8217;avais jamais rencontrée. Celle-ci vise à extraire la valeur d&amp;#8217;un bit du contenu d&amp;#8217;une variable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Cette astuce est utilisée dans le code source de la fonction &lt;code&gt;shiftOut()&lt;/code&gt; disponible dans le fichier &lt;code&gt;wiring_shift.c&lt;/code&gt; (&amp;#8594; répertoire &lt;code&gt;Contents/Java/hardware/arduino/avr/cores/arduino&lt;/code&gt; du paquet &lt;code&gt;Arduino.app&lt;/code&gt; sous Mac OSX). Elle apparaît au niveau de la spécification du 2&lt;sup&gt;ième&lt;/sup&gt; argument des fonctions &lt;code&gt;digitalWrite()&lt;/code&gt; contenues dans le bloc &lt;code&gt;if&amp;#8230;&amp;#8203;else&amp;#8230;&amp;#8203;&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight nowrap&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
   uint8_t i;

   for (i = 0; i &amp;lt; 8; i++)  {
      if (bitOrder == LSBFIRST)
         digitalWrite(dataPin, !!(val &amp;amp; (1 &amp;lt;&amp;lt; i)));
         //                    ~~~~~~~~~~~~~~~~~~
      else
         digitalWrite(dataPin, !!(val &amp;amp; (1 &amp;lt;&amp;lt; (7 - i))));
         //                    ~~~~~~~~~~~~~~~~~~~~~~~~

      digitalWrite(clockPin, HIGH);
      digitalWrite(clockPin, LOW);
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Cette fonction consiste à envoyer sur la broche &lt;code&gt;dataPin&lt;/code&gt; de l&amp;#8217;Arduino et les unes après les autres, les valeurs des 8 bits d&amp;#8217;un octet &lt;code&gt;val&lt;/code&gt; (on parle aussi de &lt;strong&gt;sérialisation&lt;/strong&gt; de l&amp;#8217;octet). L&amp;#8217;ordre dans lequel les bits sont envoyés est déterminé par le paramètre &lt;code&gt;bitOrder&lt;/code&gt; (&lt;code&gt;LSBFIRST&lt;/code&gt; &amp;#8594; bit de poids faible en 1&lt;sup&gt;ier&lt;/sup&gt;). Chaque envoi de bit sur la broche &lt;code&gt;dataPin&lt;/code&gt; est enfin signalé par l&amp;#8217;émission d&amp;#8217;une impulsion sur la broche &lt;code&gt;clockPin&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Le schéma ci-dessous illustre un cas typique d&amp;#8217;utilisation de cette fonction dans un montage qui commande simultanément les 8 broches d&amp;#8217;entrée d&amp;#8217;un afficheur 7 segments en ne mobilisant que 2 broches de l&amp;#8217;Arduino. La broche &lt;code&gt;dataPin&lt;/code&gt; de l&amp;#8217;Arduino (signal &lt;code&gt;SDI&lt;/code&gt; sur le schéma) est reliée à la broche &lt;code&gt;DS&lt;/code&gt; du registre à décalage référencé &lt;a href=&#34;http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf&#34;&gt;74HC595&lt;/a&gt; qui est utilisé ici dans le mode &lt;em&gt;Serial IN - Parallel OUT&lt;/em&gt;. La broche &lt;code&gt;clockPin&lt;/code&gt; (signal &lt;code&gt;SCLK&lt;/code&gt; sur le schéma) est quant à elle reliée à la broche &lt;code&gt;SH_CP&lt;/code&gt; de ce même composant.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock note&#34;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-note&#34; title=&#34;Note&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;En réalité, une 3&lt;sup&gt;ième&lt;/sup&gt; broche de l&amp;#8217;Arduino est utilisée. Celle-ci est nommée LATCH sur le schéma mais vu qu&amp;#8217;elle ne sert pas pour le processus de (dé)sérialisation de l&amp;#8217;octet, elle n&amp;#8217;est pas comptabilisée.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34; style=&#34;text-align: center&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;a class=&#34;image&#34; href=&#34;https://infores-sn.github.io/img/20170106/schema_74hc595.png&#34;&gt;&lt;img src=&#34;https://infores-sn.github.io/img/20170106/schema_74hc595.png&#34; alt=&#34;schema 74hc595&#34; width=&#34;800&#34;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Mais, revenons à l&amp;#8217;astuce en question&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Dans le 1&lt;sup&gt;ier&lt;/sup&gt; &lt;code&gt;digitalWrite()&lt;/code&gt;, le 2&lt;sup&gt;ième&lt;/sup&gt; argument est spécifié par l&amp;#8217;expression &lt;code&gt;!!(val &amp;amp; (1 &amp;lt;&amp;lt; i)&lt;/code&gt;. Celle-ci permet de déterminer la valeur du bit de rang &lt;code&gt;i&lt;/code&gt; de l&amp;#8217;octet &lt;code&gt;val&lt;/code&gt; à générer sur la broche &lt;code&gt;dataPin&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Cette expression m&amp;#8217;a un peu intrigué au départ car elle fait usage à la fois d&amp;#8217;opérateurs de logique booléenne et d&amp;#8217;opérateurs agissant sur des bits (&lt;em&gt;bitwise operators&lt;/em&gt; en anglais ou &amp;#8220;opérateurs bit à bit&amp;#8221; en français). Le &lt;code&gt;!&lt;/code&gt; correspond ainsi à la négation de l&amp;#8217;algèbre de Boole tandis que le &lt;code&gt;&amp;amp;&lt;/code&gt; et le &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; correspondent respectivement aux opérations bit à bit du ET et du décalage à gauche.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Or, faire intervenir des opérateurs à ce point différents dans le cadre d&amp;#8217;une même expression suscite toujours chez moi de la défiance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Avant de décomposer cette expression sur un cas concret afin de &amp;#8220;démontrer&amp;#8221; le bien fondé de l&amp;#8217;astuce, rappelons comment, au niveau du langage C, les valeurs de vérité des propositions booléennes sont déterminées :&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sont considérées comme FAUSSES les expressions dont l&amp;#8217;évaluation donne 0 ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sont considérées comme VRAIES les expressions dont l&amp;#8217;évaluation donne un nombre &lt;strong&gt;différent de 0&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Dnas le cadre de la démonstration, considérons que &lt;code&gt;val&lt;/code&gt; contient la valeur binaire &lt;code&gt;10100101&lt;/code&gt; et que la valeur décimale de &lt;code&gt;i&lt;/code&gt; est &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;L&amp;#8217;évaluation de &lt;code&gt;(1&amp;lt;&amp;lt;i)&lt;/code&gt; mène à la valeur binaire &lt;code&gt;00000100&lt;/code&gt; (1 décalé de 2 positions vers la gauche).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;L&amp;#8217;évaluation de &lt;code&gt;(val &amp;amp; (1 &amp;lt;&amp;lt; i)&lt;/code&gt;, qui correspond à une opération dîte de &lt;strong&gt;masquage&lt;/strong&gt;, mène également à la valeur binaire &lt;code&gt;00000100&lt;/code&gt; ou &lt;code&gt;4&lt;/code&gt; en décimal. En effet :&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;   10100101
 &amp;amp; 00000100
 ----------
   00000100&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;La suite de l&amp;#8217;évaluation portant sur la double négation est plus délicate. En effet, la négation de la valeur &lt;code&gt;4&lt;/code&gt;, c&amp;#8217;est-à-dire VRAI dans un contexte booléen, va bien nous donner 0 (&amp;#8594; FAUX) et la négation de ce résultat va nous donner VRAI. Cependant, qu&amp;#8217;est-ce qui nous garantit que la valeur numérique de ce VRAI sera le &lt;code&gt;1&lt;/code&gt; attendu puisqu&amp;#8217;en C le VRAI n&amp;#8217;est qu&amp;#8217;un nombre différent de 0 ?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Je pense avoir trouvé la réponse dans le paragraphe &lt;strong&gt;6.5.3.3 Unary arithmetic operators&lt;/strong&gt; de la &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf&#34;&gt;norme ISO/IEC 9899:TC3&lt;/a&gt; qui spécifie le langage C dans sa version C99.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The result of the logical negation operator ! is 0 if the value of its operand compares unequal to 0, 1 &lt;strong&gt;if the value of its operand compares equal to 0&lt;/strong&gt;. The result has type int. The expression !E is equivalent to (0==E).&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;attribution&#34;&gt;
&amp;#8212; ISO/IEC 9899:TC3 - Programming languages - C
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Conformément à ce que dit la norme dans la dernière partie de la 1&lt;sup&gt;ière&lt;/sup&gt; phrase, le résultat final de l&amp;#8217;évaluation de l&amp;#8217;ensemble de l&amp;#8217;expression de notre exemple donnera donc bien la valeur attendue, c&amp;#8217;est-à-dire &lt;code&gt;1&lt;/code&gt;, pour le bit de rang 2 de &lt;code&gt;val&lt;/code&gt; (i.e. le 3&lt;sup&gt;ième&lt;/sup&gt; bit en partant de la droite) . En effet, &lt;code&gt;!!(val &amp;amp; (1 &amp;lt;&amp;lt; i) = !!(4) = !(!(4)) = !(0) = 1&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Afin d&amp;#8217;être complet, considérons à présent un bit à 0 dans l&amp;#8217;octet &lt;code&gt;val&lt;/code&gt; en prenant &lt;code&gt;i = 4&lt;/code&gt;. L&amp;#8217;évaluation de &lt;code&gt;(val &amp;amp; (1 &amp;lt;&amp;lt; i)&lt;/code&gt; mène cette fois à la valeur binaire &lt;code&gt;00000000&lt;/code&gt; ou simplement &lt;code&gt;0&lt;/code&gt; en décimal. En effet :&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;   10100101
 &amp;amp; 00010000
 ----------
   00000000&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;L&amp;#8217;ensemble de l&amp;#8217;expression nous donne bien &lt;code&gt;0&lt;/code&gt;. En effet, &lt;code&gt;!!(val &amp;amp; (1 &amp;lt;&amp;lt; i) = !!(0) = !(!(0)) = !(1) = 0&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;L&amp;#8217;accès aux bits d&amp;#8217;une valeur numérique devient inévitable au fur et à mesure que l&amp;#8217;on se rapproche du matériel (interprétation de la valeur d&amp;#8217;un registre de composant programmable, analyse d&amp;#8217;une trame de communication&amp;#8230;&amp;#8203;). De nombreuses techniques utilisant les opérateurs bit à bit du langage C existent (voir par exemple l&amp;#8217;incontournable article : &lt;a href=&#34;https://graphics.stanford.edu/~seander/bithacks.html&#34;&gt;&#34;Bit Twiddling Hacks&#34;&lt;/a&gt;). Cependant, malgré sa simplicité apparente, l&amp;#8217;astuce vue dans ce billet m&amp;#8217;a intrigué la 1&lt;sup&gt;ière&lt;/sup&gt; fois que je l&amp;#8217;ai rencontrée dans la mesure où son expression considérait tour à tour ses opérandes comme des valeurs numériques puis booléennes pour enfin aboutir à une valeur numérique.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Dans l&amp;#8217;éventualité où certains auraient été surpris comme moi par l&amp;#8217;expression de cette astuce, j&amp;#8217;espère avoir apporté une réponse satisfaisante.&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&#34;tableblock frame-none grid-none spread&#34;&gt;
&lt;colgroup&gt;
&lt;col style=&#34;width: 100%;&#34;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;tableblock halign-center valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;&lt;span class=&#34;red&#34;&gt;&lt;span class=&#34;icon&#34;&gt;&lt;i class=&#34;fa fa-power-off fa-2x&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>
